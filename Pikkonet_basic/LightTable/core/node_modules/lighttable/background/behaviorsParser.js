var opposites = {
  "(": ")",
  "[": "]",
  "{": "}",
  ")": "(",
  "]": "[",
  "}": "{"
};

var chars = /[^\s\)\]\}]/;

//{:+ {:app [:foo (:blah "asdf" {:foo 234}) :zomg]}}
//var example = "{:+ {:app [(:lt.objs.style/set-skin \"dark\")\n           (:lt.plugins.vim/map-keys {\"-\" \"$\",\n                                      \"0\" \"^\",\n                                      \"<BS>\" \"<PageUp>\",\n                                      \"<Space>\" \"<PageDown>\",\n                                      \"j\" \"gj\",\n                                      \"k\" \"gk\"})\n           :lt.objs.intro/show-new-file \n           ],\n\n     :editor [:lt.plugins.vim/activate-vim\n              :lt.objs.editor/no-wrap\n              :lt.plugins.rainbow-parens/rainbow-parens\n              :lt.plugins.auto-complete/auto-show-on-input\n              (:lt.objs.style/set-theme \"ibdknox\")],\n\n     :editor.behaviors [:lt.plugins.rainbow-parens/rainbow-parens],\n\n     :editor.clj [:lt.plugins.rainbow-parens/rainbow-parens],\n\n     :editor.clj.instarepl [:lt.plugins.rainbow-parens/rainbow-parens\n                            (:lt.objs.langs.clj/print-length 1000)],\n\n     :editor.cljs [:lt.plugins.rainbow-parens/rainbow-parens],\n\n     :editor.javascript [(:lt.plugins.jshint/jshint-options {:maxparams false})\n                         :lt.plugins.jshint/on-save],\n\n     :editor.keymap [:lt.plugins.rainbow-parens/rainbow-parens],\n\n     :editor.markdown [:lt.objs.editor/wrap],\n\n     :editor.plaintext [:lt.objs.editor/wrap],\n\n     :editor.python [(:lt.objs.style/set-theme \"tomorrow-night\")],\n\n     :files [(:lt.objs.files/file-types [{:exts [:wisp],\n                                          :mime \"text/x-clojurescript\",\n                                          :name \"Wisp\",\n                                          :tags [:editor.wisp]}])]},\n\n :- {:app [:lt.objs.intro/show-intro]}}\n";


//{:+ {:app {"a" [:foo]}}}

//parseKeymap(new CodeMirror.StringStream("{:+ {:app {\"a\" [:foo (:do-something \"hey\" :woo)]}}}"));

function parseBehaviors(stream) {

  var state = { addSub: null, tag: null, behavior: null, level: 0, stack: [], args: [] };
  var errors = [];
  var positions = [];

  stream.eatSpace();
  while(stream.peek()) {
    var ch = stream.next();

    if (ch == "\"") {
      state.mode = "string";
      var pos = stream.pos;
      var next, escaped = false;
      while ((next = stream.next()) != null) {
        if (next == "\"" && !escaped) {

          state.mode = false;
          break;
        }
        escaped = !escaped && next == "\\";
      }

      if(state.level == 4) {
        state.args.push({from: pos - 1, to: stream.pos});
      }
    } else if (ch == ";") { // comment
      stream.skipTo("\n"); // rest of the line is a comment

    } else if (ch == "(" || ch == "[" || ch == "{") {
      state.stack.push({type: ch, pos: stream.pos});
      state.level++;

      if(state.level == 5) {
        state.argpos = stream.pos;
      }

    } else if (ch == ")" || ch == "]" || ch == "}") {
      if(state.stack.length && state.stack[state.stack.length - 1].type == opposites[ch]) {
        state.stack.pop();
        state.level--;

        stream.backUp(1);

        if(state.level == 4) {
          state.args.push({from: state.argpos - 1, to: stream.pos});
        } else if(state.level == 3) {
          positions.push({from: stream.start, to: stream.pos, addSub: state.addSub, tag: state.tag, behavior: state.behavior, args: state.args});
          state.behavior = null;
          state.args = [];
        } else if(state.level == 2) {
          state.behavior = null;
          state.tag = null;
          state.args = [];
        } else if(state.level == 1) {
          state.tag = null;
          state.addSub = null;
        } else if(state.level === 0) {
          state.addSub = null;
        }

        stream.next();

      } else {
        var expected = "the end of the file";
        if(state.stack[state.stack.length - 1]) {
          var expected = opposites[state.stack[state.stack.length - 1].type];
        }
        errors.push({error: "Unmatched delimiter " + ch + " expected to see " + expected + "", from: stream.start, to: stream.pos});
      }


    } else if ( ch == ":" ) {
      if(state.level <= 4) {
        stream.start = stream.pos - 1;
        stream.eatWhile(chars);
      }
      if(!state.addSub && state.level == 1) {
        state.addSub = stream.current();
        if(state.addSub != ":+" && state.addSub != ":-") {
          errors.push({error: "Unknown diff key: " + state.addSub + ". Only :+ and :- are allowed.", from: stream.start, to: stream.pos});
        }
      } else if(!state.tag && state.level == 2) {
        state.tag = stream.current();
      } else if(!state.behavior && state.level == 3) {
        positions.push({from: stream.start, to: stream.pos, addSub: state.addSub, tag: state.tag, behavior: stream.current()});

      } else if(!state.behavior && state.level == 4) {
        state.behavior = stream.current();

      } else if(state.level == 4) {
        var pos = stream.pos;
        stream.eatWhile(chars);
        state.args.push({from: pos, to: stream.pos});
      }
    } else if(state.level == 4 && ch.match(chars)) {
      var pos = stream.pos;
      stream.eatWhile(chars);
      state.args.push({from: pos - 1, to: stream.pos});
    }
  }

  return {errors: errors, positions: positions};
}

function parseKeymap(stream) {

  var state = { addSub: null, tag: null, key: null, command: null, level: 0, stack: [], args: [] };
  var errors = [];
  var positions = [];

  stream.eatSpace();
  while(stream.peek()) {
    var ch = stream.next();

    if (ch == "\"") {
      state.mode = "string";
      var pos = stream.pos - 1;
      var next, escaped = false;
      while ((next = stream.next()) != null) {
        if (next == "\"" && !escaped) {

          state.mode = false;
          break;
        }
        escaped = !escaped && next == "\\";
      }

      if(state.level == 3) {
        stream.start = pos + 1;
        stream.backUp(1);
        state.key = stream.current();
        stream.next();
        positions.push({from: pos, to: stream.pos, addSub: state.addSub, tag: state.tag, key: state.key});
      }

      if(state.level == 5) {
        state.args.push({from: pos - 1, to: stream.pos});
      }
    } else if (ch == ";") { // comment
      stream.skipTo("\n"); // rest of the line is a comment

    } else if (ch == "(" || ch == "[" || ch == "{") {
      state.stack.push({type: ch, pos: stream.pos});
      state.level++;

      if(state.level == 6) {
        state.argpos = stream.pos;
      }

    } else if (ch == ")" || ch == "]" || ch == "}") {
      if(state.stack.length && state.stack[state.stack.length - 1].type == opposites[ch]) {
        state.stack.pop();
        state.level--;

        stream.backUp(1);

        if(state.level == 5) {
          state.args.push({from: state.argpos - 1, to: stream.pos});
        } else if(state.level == 4) {
          positions.push({from: stream.start, to: stream.pos, addSub: state.addSub, tag: state.tag, key: state.key, command:state.command, args: state.args});
          state.command = null;
          state.args = [];
        } else if(state.level == 3) {
          state.command = null;
          state.key = null;
          state.args = [];
        } else if(state.level == 2) {
          state.tag = null;
        } else if(state.level == 1) {
          state.tag = null;
          state.addSub = null;
        } else if(state.level === 0) {
          state.addSub = null;
        }

        stream.next();

      } else {
        errors.push({error: "Unmatched delimiter " + ch + " expected to see " + opposites[state.stack[state.stack.length - 1].type] + "", from: stream.start, to: stream.pos});
      }


    } else if ( ch == ":" ) {
      if(state.level <= 5) {
        stream.start = stream.pos - 1;
        stream.eatWhile(chars);
      }
      if(!state.addSub && state.level == 1) {
        state.addSub = stream.current();
        if(state.addSub != ":+" && state.addSub != ":-") {
          errors.push({error: "Unknown diff key: " + state.addSub + ". Only :+ and :- are allowed.", from: stream.start, to: stream.pos});
        }
      } else if(!state.tag && state.level == 2) {
        state.tag = stream.current();
      } else if(!state.command && state.level == 4) {
        positions.push({from: stream.start, to: stream.pos, addSub: state.addSub, tag: state.tag, key:state.key, command: stream.current()});

      } else if(!state.command && state.level == 5) {
        state.command = stream.current();

      } else if(state.level == 6) {
        var pos = stream.pos;
        stream.eatWhile(chars);
        state.args.push({from: pos, to: stream.pos});
      }
    } else if(state.level == 6 && ch.match(chars)) {
      var pos = stream.pos;
      stream.eatWhile(chars);
      state.args.push({from: pos - 1, to: stream.pos});
    }
  }

  return {errors: errors, positions: positions};
}

exports.parseBehaviors = parseBehaviors;
exports.parseKeymap = parseKeymap;
